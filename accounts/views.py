#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

import datetime
import json

import arrow
import stripe
from django.conf import settings
from django.contrib import auth, messages
from django.contrib.auth.decorators import login_required
from django.core.urlresolvers import reverse
from django.http import HttpResponse
from django.shortcuts import redirect, render
from django.template.context_processors import csrf
from django.utils import timezone
from django.views.decorators.csrf import csrf_exempt

from accounts.forms import UserLoginForm, UserRegistrationForm
from models import User

# stripe api_key initialised to our Stripe Secret Key declared in settings.py
stripe.api_key = settings.STRIPE_SECRET


# Create your views here.
def register(request):
    if request.method == 'POST':
        form = UserRegistrationForm(request.POST)
        if form.is_valid():
            try:
                customer = stripe.Customer.create(
                    email=form.cleaned_data['email'],
                    # this is currently the card token/id
                    card=form.cleaned_data['stripe_id'],
                    plan='REG_MONTHLY',
                )
                if customer:
                    user = form.save()
                    user.stripe_id = customer.id
                    user.subscription_end = arrow.now().replace(weeks=+4).datetime
                    user.save()
                    user = auth.authenticate(email=request.POST.get('email'),
                                             password=request.POST.get('password1'))

                    if user:
                        auth.login(request, user)
                        messages.success(
                            request, "You have successfully registered")
                        return redirect(reverse('profile'))
                    else:
                        messages.error(
                            request, "unable to log you in at this time!")
                else:
                    messages.error(
                        request, "We were unable to take a payment with that card!")
            except stripe.error.CardError, e:
                messages.error(request, "Your card was declined!")
    else:
        today = datetime.date.today()
        form = UserRegistrationForm()

    args = {'form': form, 'publishable': settings.STRIPE_PUBLISHABLE}
    args.update(csrf(request))

    return render(request, 'register.html', args)


def login(request):
    if request.method == 'POST':
        form = UserLoginForm(request.POST)
        if form.is_valid():
            user = auth.authenticate(email=request.POST.get('email'),
                                     password=request.POST.get('password'))

            if user is not None:
                now = timezone.now()
                if user.subscription_end > now:
                    auth.login(request, user)
                    messages.error(
                        request, "You have successfully logged in")
                    return redirect(reverse('profile'))
                else:
                    form.add_error(None, "SORRY!, You're subscription has expired!")
            else:
                form.add_error(None, "Your email or password was not recognised")

    else:
        form = UserLoginForm()

    args = {'form': form}
    args.update(csrf(request))
    return render(request, 'login.html', args)


@login_required(login_url='/login/')
def profile(request):
    return render(request, 'profile.html')


# prevent Django from blocking the call from Stripe
@csrf_exempt
def subscriptions_webhook(request):
    # turn our JSON module into a dict so we can easily work with the values
    event_json = json.loads(request.body)
    # verify the event by fetching it from stripe
    try:
        # firstly verify this is a real event generated by Stripe.com
        # commented out for testing - uncomment when live
        #This won’t work when testing on a localhost 
        # (the stripe webhook needs to point to a domain or publicly available IP address) 
        # so we have it commented out for testing.
        # event = stripe.Event.retrieve(event_json['object']['id'])
        cust = event_json['object']['customer']
        paid = event_json['object']['paid']
        # verify th data came from stripe so we know we have a valid event
        user = User.objects.get(stripe_id=cust)

        # find our customer by stripe ID and verify they have paid
        if user and paid:
            # if all checks out, update the subscription end and save
            user.subscription_end = arrow.now().replace(weeks=+4).datetime # 4 weeks from now
            user.save()

    except stripe.InvalidRequestError, e:
        return HttpResponse(status=404)
    return HttpResponse(status=200)


@login_required(login_url='/login/')
def cancel_subscription(request):
    try:
        # retrieves an instance of the stripe customer and gets the stripe_id
        customer = stripe.Customer.retrieve(request.user.stripe_id)
        # call the cancel subscription method if the users wishes to cancel
        """
        At this point, you could choose to stop the subscription right away, 
        but in our case, we’re going to be kind and allow them to use the service until the billing period has ended.
        If we did want to end the subscription now, we could have used arrow to set the subscription_end field on our user to ‘arrow.now()’.
        """
        customer.cancel_subscription(at_period_end=True)
    except Exception, e:
        messages.error(request, e)
    return redirect('profile')


def logout(request):
    auth.logout(request)
    messages.success(request, 'You have successfully logged out')
    return redirect(reverse('index'))
